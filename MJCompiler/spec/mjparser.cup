

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal BOOLCONST;

terminal PROG;
terminal BREAK, RETURN, CONTINUE;
terminal CONST, VOID;
terminal CLASS, EXTENDS, NEW;
terminal ELSE, IF, SWITCH, CASE, DO, WHILE;
terminal PRINT, READ;
terminal ADD, SUB;
terminal MUL, DIV, MOD;
terminal EQUALITY, NOEQUALITY, GREATER, GREATEREQ, LESS, LESSEQ;
terminal AND, OR;
terminal EQUAL;
terminal INC, DEC;
terminal SEMI, COMMA, DOT;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LSQUARE, RSQUARE;
terminal QUESTION, DDOT;
terminal DEFAULT, YIELD;


nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodDecl, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, MethodType, Factor, Term, Expr1, Expr, DesignatorStatement;

nonterminal ParamDecl;
nonterminal ConstDecl, ConstVal, ConstDeclRest;
nonterminal VarDecl, OptSquare, VarDeclRest;
nonterminal VarDeclList, MethodDeclList;
nonterminal ClassDecl, ClassMethods;
nonterminal OptFormPars;
nonterminal FormPars, FormParamDecl;
nonterminal Statement, Matched, Unmatched, ReturnValue, PrintExpr, StmtList;
nonterminal DesignatorAssignment;
nonterminal CondFact, CondTerm, Condition;
nonterminal CaseStmt, CaseList;
nonterminal ActPars, OptionalMinus;
nonterminal ActualPars;
nonterminal Assignop, Relop, Addop, Mulop;


Program ::= (Program) PROG ProgName:p ParamDecl LBRACE MethodDeclList RBRACE;

ParamDecl ::= (ConstParam) ParamDecl ConstDecl
			|
			(VarParam) ParamDecl VarDecl
			|
			(ClassParam) ParamDecl ClassDecl
			|
			/* epsilon */
			;

ProgName ::= (ProgName) IDENT:progName;

ConstDecl ::= (ConstDecl) CONST Type:constType IDENT:constName EQUAL ConstVal:constVal ConstDeclRest SEMI
			;
			
ConstDeclRest ::= (ConstDeclMore) ConstDeclRest COMMA IDENT:constName EQUAL ConstVal:constVal
					|
					(NoConstDeclMore) /* epsilon */
					;
			
ConstVal ::= (NumConstVal) NUMBER:val
				| 
				(CharConstVal) CHARCONST:val
				|
				(BoolConstVal) BOOLCONST:val
				;

VarDecl ::= (VarDeclaration) Type:varType IDENT:varName OptSquare VarDeclRest SEMI
			|
			error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :}
			|
			error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :}
			;
			
VarDeclRest ::= (VarDeclMore) VarDeclRest COMMA IDENT:varName OptSquare
				|
				(NoVarDeclMore) /* epsilon */
				;
			
OptSquare ::= (Squares) LSQUARE RSQUARE
				|
				(NoSquares) /* epsilon */
				;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
				|
				(NoVarDecl) /* epsilon */
				; 

ClassDecl ::= (BaseClassDecl) CLASS IDENT:className LBRACE VarDeclList ClassMethods RBRACE
				|
				(ExtendedClass) CLASS IDENT:className EXTENDS Type:baseClass LBRACE VarDeclList ClassMethods RBRACE
				;
				
ClassMethods ::= (ClassMethodList) LBRACE MethodDeclList RBRACE
				|
				(NoClassMethods) /* epsilon */
				;
				
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDeclarations) /* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName LPAREN OptFormPars RPAREN VarDeclList LBRACE StmtList RBRACE;

MethodTypeName ::= (MethodTypeName) MethodType:retType IDENT:methName;

MethodType ::= (MethodRetType) Type:type
				|
				(VoidRetType) VOID:type
				;
				
OptFormPars ::= (OptFormParams) FormParamDecl FormPars
				|
				(NoFormPars) /* epsilon */
				;

FormPars ::= (FormParams) FormPars COMMA FormParamDecl
			|
			(NoFormParams) /* epsilon */
			|
			error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :}
			;

FormParamDecl ::= (FormParam) Type:paramType IDENT:paramName OptSquare	
				|
				error:l
				{: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null);  :}	
				;

Type ::= (Type) IDENT:type;

Statement ::= (MatchedStmt) Matched
				|
			  	(UnmatchedStmt) Unmatched
			  	;

Unmatched ::= 	(UnmatchedIf) IF LPAREN Condition RPAREN Statement
				|
				(UnmatchedIfElse) IF LPAREN Condition RPAREN Matched ELSE Unmatched
				|
				error RPAREN:l
				{: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null);  :}	
				;

Matched ::= (DesStmt) DesignatorStatement SEMI
			|
			(MatchedIfElse) IF LPAREN Condition RPAREN Matched ELSE Matched
			|
			(DoWhileStmt) DO Statement WHILE LPAREN Condition RPAREN SEMI
			|
			(YieldStmt) YIELD Expr SEMI
			|
			(BreakStmt) BREAK SEMI
			|
			(ContinueStmt) CONTINUE SEMI
			|
			(RetStmt) RETURN ReturnValue:retVal SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStmt) PRINT LPAREN PrintExpr RPAREN SEMI
			|
			(BasicStmt) LBRACE StmtList RBRACE
			;
			
StmtList ::= (MultiStmtList) StmtList Statement
			|
			(NoStmt) /* epsilon */
			;
			
ReturnValue ::= (RetVal) Expr:retVal
				|
				(NoRetVal) /* epsilon */
				;
				
PrintExpr ::= (MultiPrintExpr) Expr COMMA NUMBER
				|
				(SinglePrintExpr) Expr
				;

DesignatorStatement ::= (DesAssign) DesignatorAssignment
						|
						(ProcedureCall) Designator:procName LPAREN ActualPars RPAREN
						|
						(VarInc) Designator:varName INC
						|
						(VarDec) Designator:varName DEC
						;


DesignatorAssignment ::= (Assign) Designator:varName Assignop Expr:val
						|
						(AssignError) error:l
						;

ActPars ::= (MultipleParam) ActPars COMMA Expr:paramName
			|
			(SingleParam) Expr:paramName
			;

Condition ::= (OrCond) Condition:cond1 OR CondTerm:cond2
			|
			(SimpleCond) CondTerm:cond
			;

CondTerm ::= (AndCond) CondTerm:cond1 AND CondFact:cond2
			|
			(SimpleCondTerm) CondFact:cond
			;

CondFact ::= (CondExpr) Expr:expr
			|
			(CompareExpr) Expr:comp1 Relop Expr:comp2
			;

Expr ::= (TernarOperator) Expr1:condition QUESTION Expr1:trueB DDOT Expr1:falseB
		|
		(BasicExpr) Expr1:expr
		|
		(SwitchExpretion) SWITCH LPAREN Expr:chooseVal RPAREN LBRACE CaseStmt RBRACE
		;
		
CaseStmt ::= (CaseStmt) CaseList DEFAULT:caseLabel DDOT YIELD Expr:caseRetVal SEMI;

CaseList ::= (MultiCaseList) CaseList CASE NUMBER:caseLabel DDOT StmtList
			|
			(NoCase) /* epsilon */
			;

Expr1 ::= (AddExpr) Expr1:term Addop Term:t
		|
		(TermExpr) OptionalMinus Term:term
		;

OptionalMinus ::= (Minus) SUB
				|
				(NoMinus) /* epsilon */
				;

Term ::= (MulopTerm) Term:term Mulop Factor:factor
		|
		(FactorTerm) Factor:factor
		;	 

Factor ::= 	(Var) Designator:varName
			|
			(FuncCall) Designator:funcName LPAREN ActualPars RPAREN
			|
			(NumConst) NUMBER:numConst
			|
			(CharConst) CHARCONST:charConst
			|
			(BoolConst) BOOLCONST:boolConst
			|
			(NewOp) NEW Type:varType
			|
			(NewArray) NEW Type:varType LSQUARE Expr:elemNum RSQUARE
			|
			(FactExpr) LPAREN Expr RPAREN
			;
			
ActualPars ::= (Actuals) ActPars
				|
				(NoActuals) /* epsilon */
				;

Designator ::= (DesBasic) IDENT:varName
				|
				(DesArray) Designator:varName LSQUARE Expr:arrayIndex RSQUARE
				|
				(DesObject) Designator:varName DOT IDENT:field
				;

Assignop ::= (AssignOperator) EQUAL;

Relop ::= (EqualsOperator) EQUALITY
		|
		(NotEqualsOperator) NOEQUALITY
		|
		(GreaterOperator) GREATER
		|
		(GreaterEqOperator) GREATEREQ
		|
		(LessOperator) LESS
		|
		(LessEqOperator) LESSEQ
		;

Addop ::= (AddOperator) ADD
		|
		(SubOperator) SUB
		;

Mulop ::= (MulOperator) MUL 
		|
		(DivOperator) DIV
		|
		(ModOperator) MOD
		;












