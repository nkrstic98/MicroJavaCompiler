

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());
	
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHARCONST;
terminal String BOOLCONST;

terminal PROG;
terminal BREAK, RETURN, CONTINUE;
terminal CONST, VOID;
terminal CLASS, EXTENDS, NEW;
terminal ELSE, IF, SWITCH, CASE, DO, WHILE;
terminal PRINT, READ;
terminal ADD, SUB;
terminal MUL, DIV, MOD;
terminal EQUALITY, NOEQUALITY, GREATER, GREATEREQ, LESS, LESSEQ;
terminal AND, OR;
terminal EQUAL;
terminal INC, DEC;
terminal SEMI, COMMA, DOT;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LSQUARE, RSQUARE;
terminal QUESTION, DDOT;
terminal DEFAULT, YIELD;


nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodDecl, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, MethodType, Factor, Term, Expr1, Expr, DesignatorStatement;

nonterminal ParamDecl ParamDecl;
nonterminal ConstDecl ConstDecl;
nonterminal ConstAssign ConstAssign;
nonterminal VarDecl VarDecl;
nonterminal OptSquare OptSquare;
nonterminal VarDeclRest VarDeclRest;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal ClassDecl ClassDecl;
nonterminal ClassMethods ClassMethods;
nonterminal OptFormPars OptFormPars;
nonterminal FormPars FormPars;
nonterminal FormParamDecl FormParamDecl;
nonterminal Statement Statement;
nonterminal Matched Matched;
nonterminal Unmatched Unmatched;
nonterminal PrintExpr PrintExpr;
nonterminal StmtList StmtList;
nonterminal DesignatorAssignment DesignatorAssignment;
nonterminal CondFact CondFact;
nonterminal CondTerm CondTerm;
nonterminal Condition Condition;
nonterminal CaseStmt CaseStmt;
nonterminal CaseList CaseList;
nonterminal ActPars ActPars;
nonterminal OptionalMinus OptionalMinus;
nonterminal ActualPars ActualPars;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;


Program ::= (Program) PROG ProgName:p ParamDecl:P1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, P1, M2); RESULT.setLine(pleft); :};

ParamDecl ::= (ConstParam) ParamDecl:P1 ConstDecl:C2 {: RESULT=new ConstParam(P1, C2); RESULT.setLine(P1left); :}
			|
			(VarParam) ParamDecl:P1 VarDecl:V2 {: RESULT=new VarParam(P1, V2); RESULT.setLine(P1left); :}
			|
			(ClassParam) ParamDecl:P1 ClassDecl:C2 {: RESULT=new ClassParam(P1, C2); RESULT.setLine(P1left); :}
			| {: RESULT=new ParamDeclDerived1(); :}
			/* epsilon */
			;

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

ConstDecl ::= (ConstDecl) CONST Type:constType ConstAssign:C1 SEMI {: RESULT=new ConstDecl(constType, C1); RESULT.setLine(constTypeleft); :}
			;
			
ConstAssign ::= (SingleNumberConst) IDENT:constName EQUAL NUMBER:constVal {: RESULT=new SingleNumberConst(constName, constVal); RESULT.setLine(constNameleft); :}
				|
				(MultiNumberConst) ConstAssign:C1 COMMA IDENT:constName EQUAL NUMBER:constVal {: RESULT=new MultiNumberConst(C1, constName, constVal); RESULT.setLine(C1left); :}
				|
				(SingleCharConst) IDENT:constName EQUAL CHARCONST:constVal {: RESULT=new SingleCharConst(constName, constVal); RESULT.setLine(constNameleft); :}
				|
				(MultiCharConst) ConstAssign:C1 COMMA IDENT:constName EQUAL CHARCONST:constVal {: RESULT=new MultiCharConst(C1, constName, constVal); RESULT.setLine(C1left); :}
				|
				(SingleBoolConst )IDENT:constName EQUAL BOOLCONST:constVal {: RESULT=new SingleBoolConst(constName, constVal); RESULT.setLine(constNameleft); :}
				|
				(MultiBoolConst) ConstAssign:C1 COMMA IDENT:constName EQUAL BOOLCONST:constVal {: RESULT=new MultiBoolConst(C1, constName, constVal); RESULT.setLine(C1left); :}
				;
				
VarDecl ::= (VarDeclaration) Type:varType IDENT:varName OptSquare:O1 VarDeclRest:V2 SEMI {: RESULT=new VarDeclaration(varType, varName, O1, V2); RESULT.setLine(varTypeleft); :}
			|
			error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new VarDeclDerived1(); :}
			|
			error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :} {: RESULT=new VarDeclDerived2(); :}
			;
			
VarDeclRest ::= (VarDeclMore) VarDeclRest:V1 COMMA IDENT:varName OptSquare:O2 {: RESULT=new VarDeclMore(V1, varName, O2); RESULT.setLine(V1left); :}
				|
				(NoVarDeclMore) {: RESULT=new NoVarDeclMore(); :} /* epsilon */
				;
			
OptSquare ::= (Squares) LSQUARE RSQUARE {: RESULT=new Squares(); :}
				|
				(NoSquares) {: RESULT=new NoSquares(); :} /* epsilon */
				;

VarDeclList ::= (VarDeclarations) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}
				|
				(NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon */
				; 

ClassDecl ::= (BaseClassDecl) CLASS IDENT:className LBRACE VarDeclList:V1 ClassMethods:C2 RBRACE {: RESULT=new BaseClassDecl(className, V1, C2); RESULT.setLine(classNameleft); :}
				|
				(ExtendedClass) CLASS IDENT:className EXTENDS Type:baseClass LBRACE VarDeclList:V1 ClassMethods:C2 RBRACE {: RESULT=new ExtendedClass(className, baseClass, V1, C2); RESULT.setLine(classNameleft); :}
				;
				
ClassMethods ::= (ClassMethodList) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new ClassMethodList(M1); RESULT.setLine(M1left); :}
				|
				(NoClassMethods) {: RESULT=new NoClassMethods(); :} /* epsilon */
				;
				
MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName:M1 LPAREN OptFormPars:O2 RPAREN VarDeclList:V3 LBRACE StmtList:S4 RBRACE {: RESULT=new MethodDecl(M1, O2, V3, S4); RESULT.setLine(M1left); :};

MethodTypeName ::= (MethodTypeName) MethodType:retType IDENT:methName {: RESULT=new MethodTypeName(retType, methName); RESULT.setLine(retTypeleft); :};

MethodType ::= (MethodRetType) Type:type {: RESULT=new MethodRetType(type); RESULT.setLine(typeleft); :}
				|
				(VoidRetType) VOID:type {: RESULT=new VoidRetType(); :}
				;
				
OptFormPars ::= (OptFormParams) FormParamDecl:F1 FormPars:F2 {: RESULT=new OptFormParams(F1, F2); RESULT.setLine(F1left); :}
				|
				(NoFormPars) {: RESULT=new NoFormPars(); :} /* epsilon */
				;

FormPars ::= (FormParams) FormPars:F1 COMMA FormParamDecl:F2 {: RESULT=new FormParams(F1, F2); RESULT.setLine(F1left); :}
			|
			(NoFormParams) {: RESULT=new NoFormParams(); :} /* epsilon */
			|
			error COMMA:l
			{: parser.report_error("Izvrsen oporavak do , u liniji " + lleft, null);  :} {: RESULT=new FormParsDerived1(); :}
			;

FormParamDecl ::= (FormParam) Type:paramType IDENT:paramName OptSquare:O1 {: RESULT=new FormParam(paramType, paramName, O1); RESULT.setLine(paramTypeleft); :}	
				|
				error:l
				{: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null);  :} {: RESULT=new FormParamDeclDerived1(); :}	
				;

Type ::= (Type) IDENT:type {: RESULT=new Type(type); RESULT.setLine(typeleft); :};

Statement ::= (MatchedStmt) Matched:M1 {: RESULT=new MatchedStmt(M1); RESULT.setLine(M1left); :}
				|
			  	(UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :}
			  	;

Unmatched ::= 	(UnmatchedIf) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new UnmatchedIf(C1, S2); RESULT.setLine(C1left); :}
				|
				(UnmatchedIfElse) IF LPAREN Condition:C1 RPAREN Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedIfElse(C1, M2, U3); RESULT.setLine(C1left); :}
				|
				error RPAREN:l
				{: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null);  :} {: RESULT=new UnmatchedDerived1(); :}	
				;

Matched ::= (DesStmt) DesignatorStatement:D1 SEMI {: RESULT=new DesStmt(D1); RESULT.setLine(D1left); :}
			|
			(MatchedIfElse) IF LPAREN Condition:C1 RPAREN Matched:M2 ELSE Matched:M3 {: RESULT=new MatchedIfElse(C1, M2, M3); RESULT.setLine(C1left); :}
			|
			(DoWhileStmt) DO Statement:S1 WHILE LPAREN Condition:C2 RPAREN SEMI {: RESULT=new DoWhileStmt(S1, C2); RESULT.setLine(S1left); :}
			|
			(YieldStmt) YIELD Expr:E1 SEMI {: RESULT=new YieldStmt(E1); RESULT.setLine(E1left); :}
			|
			(BreakStmt) BREAK SEMI {: RESULT=new BreakStmt(); :}
			|
			(ContinueStmt) CONTINUE SEMI {: RESULT=new ContinueStmt(); :}
			|
			(RetStmt) RETURN Expr:retVal SEMI {: RESULT=new RetStmt(retVal); RESULT.setLine(retValleft); :}
			|
			(RetNoValStmt) RETURN SEMI {: RESULT=new RetNoValStmt(); :}
			|
			(ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
			|
			(PrintStmt) PRINT LPAREN PrintExpr:P1 RPAREN SEMI {: RESULT=new PrintStmt(P1); RESULT.setLine(P1left); :}
			|
			(BasicStmt) LBRACE StmtList:S1 RBRACE {: RESULT=new BasicStmt(S1); RESULT.setLine(S1left); :}
			;
			
StmtList ::= (MultiStmtList) StmtList:S1 Statement:S2 {: RESULT=new MultiStmtList(S1, S2); RESULT.setLine(S1left); :}
			|
			(NoStmt) {: RESULT=new NoStmt(); :} /* epsilon */
			;
				
PrintExpr ::= (MultiPrintExpr) Expr:E1 COMMA NUMBER:N2 {: RESULT=new MultiPrintExpr(E1, N2); RESULT.setLine(E1left); :}
				|
				(SinglePrintExpr) Expr:E1 {: RESULT=new SinglePrintExpr(E1); RESULT.setLine(E1left); :}
				;

DesignatorStatement ::= (DesAssign) DesignatorAssignment:D1 {: RESULT=new DesAssign(D1); RESULT.setLine(D1left); :}
						|
						(ProcedureCall) Designator:procName LPAREN ActualPars:A1 RPAREN {: RESULT=new ProcedureCall(procName, A1); RESULT.setLine(procNameleft); :}
						|
						(VarInc) Designator:varName INC {: RESULT=new VarInc(varName); RESULT.setLine(varNameleft); :}
						|
						(VarDec) Designator:varName DEC {: RESULT=new VarDec(varName); RESULT.setLine(varNameleft); :}
						;


DesignatorAssignment ::= (Assign) Designator:varName Assignop:A1 Expr:val {: RESULT=new Assign(varName, A1, val); RESULT.setLine(varNameleft); :}
						|
						(AssignError) error:l {: RESULT=new AssignError(); :}
						;

ActPars ::= (MultipleParam) ActPars:A1 COMMA Expr:paramName {: RESULT=new MultipleParam(A1, paramName); RESULT.setLine(A1left); :}
			|
			(SingleParam) Expr:paramName {: RESULT=new SingleParam(paramName); RESULT.setLine(paramNameleft); :}
			;

Condition ::= (OrCond) Condition:cond1 OR CondTerm:cond2 {: RESULT=new OrCond(cond1, cond2); RESULT.setLine(cond1left); :}
			|
			(SimpleCond) CondTerm:cond {: RESULT=new SimpleCond(cond); RESULT.setLine(condleft); :}
			;

CondTerm ::= (AndCond) CondTerm:cond1 AND CondFact:cond2 {: RESULT=new AndCond(cond1, cond2); RESULT.setLine(cond1left); :}
			|
			(SimpleCondTerm) CondFact:cond {: RESULT=new SimpleCondTerm(cond); RESULT.setLine(condleft); :}
			;

CondFact ::= (CondExpr) Expr:expr {: RESULT=new CondExpr(expr); RESULT.setLine(exprleft); :}
			|
			(CompareExpr) Expr:comp1 Relop:R1 Expr:comp2 {: RESULT=new CompareExpr(comp1, R1, comp2); RESULT.setLine(comp1left); :}
			;

Expr ::= (TernarOperator) Expr1:condition QUESTION Expr1:trueB DDOT Expr1:falseB {: RESULT=new TernarOperator(condition, trueB, falseB); RESULT.setLine(conditionleft); :}
		|
		(BasicExpr) Expr1:expr {: RESULT=new BasicExpr(expr); RESULT.setLine(exprleft); :}
		|
		(SwitchExpretion) SWITCH LPAREN Expr:chooseVal RPAREN LBRACE CaseStmt:C1 RBRACE {: RESULT=new SwitchExpretion(chooseVal, C1); RESULT.setLine(chooseValleft); :}
		;
		
CaseStmt ::= (CaseStmt) CaseList:C1 DEFAULT:caseLabel DDOT YIELD Expr:caseRetVal SEMI {: RESULT=new CaseStmt(C1, caseRetVal); RESULT.setLine(C1left); :};

CaseList ::= (MultiCaseList) CaseList:C1 CASE NUMBER:caseLabel DDOT StmtList:S2 {: RESULT=new MultiCaseList(C1, caseLabel, S2); RESULT.setLine(C1left); :}
			|
			(NoCase) {: RESULT=new NoCase(); :} /* epsilon */
			;

Expr1 ::= (AddExpr) Expr1:term Addop:A1 Term:t {: RESULT=new AddExpr(term, A1, t); RESULT.setLine(termleft); :}
		|
		(TermExpr) OptionalMinus:O1 Term:term {: RESULT=new TermExpr(O1, term); RESULT.setLine(O1left); :}
		;

OptionalMinus ::= (Minus) SUB {: RESULT=new Minus(); :}
				|
				(NoMinus) {: RESULT=new NoMinus(); :} /* epsilon */
				;

Term ::= (MulopTerm) Term:term Mulop:M1 Factor:factor {: RESULT=new MulopTerm(term, M1, factor); RESULT.setLine(termleft); :}
		|
		(FactorTerm) Factor:factor {: RESULT=new FactorTerm(factor); RESULT.setLine(factorleft); :}
		;	 

Factor ::= 	(Var) Designator:varName {: RESULT=new Var(varName); RESULT.setLine(varNameleft); :}
			|
			(FuncCall) Designator:funcName LPAREN ActualPars:A1 RPAREN {: RESULT=new FuncCall(funcName, A1); RESULT.setLine(funcNameleft); :}
			|
			(NumConst) NUMBER:numConst {: RESULT=new NumConst(numConst); RESULT.setLine(numConstleft); :}
			|
			(CharConst) CHARCONST:charConst {: RESULT=new CharConst(charConst); RESULT.setLine(charConstleft); :}
			|
			(BoolConst) BOOLCONST:boolConst {: RESULT=new BoolConst(boolConst); RESULT.setLine(boolConstleft); :}
			|
			(NewOp) NEW Type:varType {: RESULT=new NewOp(varType); RESULT.setLine(varTypeleft); :}
			|
			(NewArray) NEW Type:varType LSQUARE Expr:elemNum RSQUARE {: RESULT=new NewArray(varType, elemNum); RESULT.setLine(varTypeleft); :}
			|
			(FactExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactExpr(E1); RESULT.setLine(E1left); :}
			;
			
ActualPars ::= (Actuals) ActPars:A1 {: RESULT=new Actuals(A1); RESULT.setLine(A1left); :}
				|
				(NoActuals) {: RESULT=new NoActuals(); :} /* epsilon */
				;

Designator ::= (DesBasic) IDENT:varName {: RESULT=new DesBasic(varName); RESULT.setLine(varNameleft); :}
				|
				(DesArray) Designator:varName LSQUARE Expr:arrayIndex RSQUARE {: RESULT=new DesArray(varName, arrayIndex); RESULT.setLine(varNameleft); :}
				|
				(DesObject) Designator:varName DOT IDENT:field {: RESULT=new DesObject(varName, field); RESULT.setLine(varNameleft); :}
				;

Assignop ::= (AssignOperator) EQUAL {: RESULT=new AssignOperator(); :};

Relop ::= (EqualsOperator) EQUALITY {: RESULT=new EqualsOperator(); :}
		|
		(NotEqualsOperator) NOEQUALITY {: RESULT=new NotEqualsOperator(); :}
		|
		(GreaterOperator) GREATER {: RESULT=new GreaterOperator(); :}
		|
		(GreaterEqOperator) GREATEREQ {: RESULT=new GreaterEqOperator(); :}
		|
		(LessOperator) LESS {: RESULT=new LessOperator(); :}
		|
		(LessEqOperator) LESSEQ {: RESULT=new LessEqOperator(); :}
		;

Addop ::= (AddOperator) ADD {: RESULT=new AddOperator(); :}
		|
		(SubOperator) SUB {: RESULT=new SubOperator(); :}
		;

Mulop ::= (MulOperator) MUL {: RESULT=new MulOperator(); :} 
		|
		(DivOperator) DIV {: RESULT=new DivOperator(); :}
		|
		(ModOperator) MOD {: RESULT=new ModOperator(); :}
		;












